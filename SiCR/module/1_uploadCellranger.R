# --- UIの定義: uploadCellrangerUI ---
uploadCellrangerUI <- function(id) {
  ns <- NS(id)
  fluidRow(
    column(6,
      offset = 1,
      shinyjs::useShinyjs(),
      
      tags$div(
        style = "border: 0.5px solid #000; padding: 10px;",
        tags$p("Please upload the filtered_feature_bc_matrix.h5 file generated by cellranger. You can optionally upload the T cell receptor file (filtered_contig_annotations.csv) and/or the B cell receptor file (filtered_contig_annotations.csv)."),
        tags$p("After uploading, click the Run button.")
      ),
      tags$div(style = "margin-top: 10px;"),
      
      fluidRow(
        column(8, fileInput(ns("h5"), "1. Choose .h5 file")),
        column(4, style = "margin-top: 25px;", uiOutput(ns("h5_status_ui")))
      ),
      fluidRow(
        column(8, fileInput(ns("tcr"), "2. Choose .tcr file (optional)")),
        column(4, style = "margin-top: 25px;", uiOutput(ns("tcr_status_ui")))
      ),
      fluidRow(
        column(8, fileInput(ns("bcr"), "3. Choose .bcr file (optional)")),
        column(4, style = "margin-top: 25px;", uiOutput(ns("bcr_status_ui")))
      ),
      
      # ### 変更点 ###
      # ボタンを"Run"の一つにまとめました
      fluidRow(
        column(3, actionButton(ns("run"), "Run", icon = icon("rocket"))),
        column(5,
               shinyjs::hidden(
                 downloadButton(ns("download_results"), "Download Results (.rds)")
               )
        )
      ),
      
      shinyjs::hidden(
        tags$div(id = ns("status_message"),
                 style = "margin-top: 15px; padding: 10px; border-radius: 5px; background-color: #f0f0f0;")
      )
    )
  )
}

# ==============================================================================
# Server ロジック (修正版)
# ==============================================================================
uploadCellrangerServer <- function(id, myReactives) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns

    output$h5_status_ui <- renderUI({ req(input$h5); tags$p("✅ Uploaded!", style = "color: green;") })
    output$tcr_status_ui <- renderUI({ req(input$tcr); tags$p("✅ Uploaded!", style = "color: green;") })
    output$bcr_status_ui <- renderUI({ req(input$bcr); tags$p("✅ Uploaded!", style = "color: green;") })

    observeEvent(input$run, {
      # --- 1. キャッシュファイルのパスを定義 ---
      cache_file_path <- "analysis_cache.rds"

      # --- 2. 入力とキャッシュの存在をチェック ---
      # キャッシュがなく、かつ.h5ファイルもアップロードされていない場合はエラー
      if (!file.exists(cache_file_path) && is.null(input$h5$datapath)) {
        shinyalert::shinyalert("Input Required", "Please upload the .h5 file for the first analysis.", type = "error")
        return()
      }

      # --- 3. UIの初期化 ---
      shinyjs::hide("download_results")
      shinyjs::disable("run")
      shinyjs::show("status_message")

      withProgress(message = 'Analysis in progress', value = 0, {
        # --- 4. キャッシュの読み込み、または新規解析の実行 ---
        if (file.exists(cache_file_path)) {
          # --- [A] キャッシュが存在する場合：読み込んでスキップ ---
          shinyjs::html(id = "status_message", html = paste0("<p style='color: #8A2BE2;'>📁 Found '", cache_file_path, "'. Loading cached analysis results...</p>"))
          incProgress(0.2, detail = "Loading cached data...")

          # キャッシュファイルを読み込む
          cached_data <- readRDS(cache_file_path)

          # myReactivesの各項目を復元
          for (name in names(cached_data)) {
            myReactives[[name]] <- cached_data[[name]]
          }

          incProgress(0.8, detail = "Cached data loaded successfully.")
          message(paste("✅ Successfully loaded all analysis results from", cache_file_path))

        } else {
          # --- [B] キャッシュが存在しない場合：新規解析を実行 ---
          shinyjs::html(id = "status_message", html = "<p style='color: blue;'>🚀 Starting new analysis pipeline... (This may take a while)</p>")

          # (1) ファイルパスの割り当て
          incProgress(0.1, detail = "Assigning file paths...")
          myReactives <- fileUpload(input, myReactives)

          # (2) .h5からSeuratオブジェクト作成
          incProgress(0.1, detail = "Loading .h5 file...")
          myReactives <- h5_to_seurat_object(myReactives)

          # (3) Seurat標準解析 (Normalization, PCA, UMAP, etc.)
          incProgress(0.2, detail = "Running basic Seurat processing...")
          myReactives <- run_seurat_object(myReactives) # この関数は内部でSeuratオブジェクトを更新

          # (4) scTypeによる細胞タイピング
          incProgress(0.1, detail = "Performing cell typing with scType...")
          tryCatch({
            message("--- Starting scType analysis ---")
            myReactives$seurat_object <- run_sctype_and_update_seurat(myReactives$seurat_object)
            message("--- scType analysis finished successfully ---")
          }, error = function(e) {
            message("!!!!!!!!!! scType Error Caught !!!!!!!!!!")
            message("Error message: ", e$message)
            shinyalert::shinyalert("scType Error", paste("Cell typing failed:", e$message), type = "error")
          })

          # (5) TCRデータ処理
          if (!is.null(myReactives$tcr_path)) {
            incProgress(0.1, detail = "Processing TCR data...")
            req(myReactives$seurat_object)
            myReactives$tcr_df <- tcr_csv_to_dataframe(myReactives$tcr_path)
            
            # Seuratメタデータとマージ
            seurat_barcodes <- rownames(myReactives$seurat_object@meta.data)
            myReactives$tcr_df <- myReactives$tcr_df %>%
              dplyr::filter(barcode %in% seurat_barcodes)
            
            metadata <- myReactives$seurat_object@meta.data %>%
              tibble::rownames_to_column(var = "barcode") %>% 
              dplyr::select(any_of(c("sample", "seurat_clusters")), barcode)
            myReactives$tcr_df <- dplyr::left_join(myReactives$tcr_df, metadata, by = "barcode")
            
            # 'tcr_status' 列をメタデータに追加
            message("--- Adding 'tcr_status' column to Seurat metadata ---")
            seurat_barcodes <- rownames(myReactives$seurat_object@meta.data)
            tcr_barcodes <- myReactives$tcr_df$barcode
            myReactives$seurat_object$tcr_status <- ifelse(seurat_barcodes %in% tcr_barcodes, "TCR positive", "TCR negative")
            message("'tcr_status' column added. Summary:")
            print(table(myReactives$seurat_object@meta.data$tcr_status))
          }

          # (6) BCRデータ処理
          if (!is.null(myReactives$bcr_path)) {
            incProgress(0.1, detail = "Processing BCR data...")
            req(myReactives$seurat_object)
            myReactives$bcr_df <- bcr_csv_to_dataframe(myReactives$bcr_path)
            
            seurat_barcodes <- rownames(myReactives$seurat_object@meta.data)
            myReactives$bcr_df <- myReactives$bcr_df %>%
              dplyr::filter(barcode %in% seurat_barcodes)
              
            metadata <- myReactives$seurat_object@meta.data %>%
              tibble::rownames_to_column(var = "barcode") %>%
              dplyr::select(any_of(c("sample", "seurat_clusters")), barcode)
            myReactives$bcr_df <- dplyr::left_join(myReactives$bcr_df, metadata, by = "barcode")

            message("--- Adding 'bcr_status' column to Seurat metadata ---")
            seurat_barcodes <- rownames(myReactives$seurat_object@meta.data)
            bcr_barcodes <- myReactives$bcr_df$barcode
            myReactives$seurat_object$bcr_status <- ifelse(seurat_barcodes %in% bcr_barcodes, "BCR positive", "BCR negative")
            message("'bcr_status' column added. Summary:")
            print(table(myReactives$seurat_object@meta.data$bcr_status))
          }
          
          # (7) 解析結果をキャッシュとして保存
          incProgress(0.1, detail = "Finalizing and saving results to cache...")
          results_to_save <- reactiveValuesToList(myReactives)
          saveRDS(results_to_save, file = cache_file_path)
          message(paste("--- ✅ Analysis complete. Results saved to", cache_file_path, "---"))
        }
      }) # withProgressの終わり

      # --- 5. 完了処理 ---
      shinyjs::html(id = "status_message", html = "<p style='color: green;'>🎉 Analysis finished successfully!</p>")
      shinyjs::enable("run")
      shinyjs::show("download_results")
      shinyjs::delay(5000, shinyjs::hide("status_message"))
    })

    output$download_results <- downloadHandler(
      filename = function() {
        # 保存するファイル名をキャッシュファイル名と合わせる
        "analysis_cache.rds"
      },
      content = function(file) {
        # サーバー上に存在するキャッシュファイルをそのままコピーしてダウンロードさせる
        file.copy("analysis_cache.rds", file)
      }
    )

  })
}

# ==============================================================================
# scType 実行のためのヘルパー関数 (デバッグメッセージ付き)
# ==============================================================================
#' @title scType を実行し、Seuratオブジェクトを更新する
#' @description Seuratオブジェクトを受け取り、scTypeによるセルタイピングを実行し、
#'              結果をメタデータに `sctype_celltype` として追加します。
#' @param seurat_obj `Seurat` オブジェクト。
#' @return `Seurat` オブジェクト。メタデータにセルタイプ情報が追加されています。
run_sctype_and_update_seurat <- function(seurat_obj) {
 
  # ### 変更点 2: 各ステップに確認メッセージを追加 ###
  message("[scType Step 1/5] Preparing scripts and marker files...")
  sctype_url <- "https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/gene_sets_prepare.R"
  sctype_script_path <- "gene_sets_prepare.R"
  if (!file.exists(sctype_script_path)) {
    download.file(sctype_url, sctype_script_path)
    message("Downloaded gene_sets_prepare.R")
  }
  
  db_url <- "https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/ScTypeDB_short.xlsx"
  db_path <- "ScTypeDB_short.xlsx"
  if (!file.exists(db_path)) {
    download.file(db_url, db_path)
    message("Downloaded ScTypeDB_short.xlsx")
  }
  
  source(sctype_script_path)
  message("[scType Step 2/5] Loading gene sets database for 'Immune system'...")
  # Suppress warnings from HGNChelper about non-approved gene symbols in the database
  suppressWarnings({
    gs_list <- gene_sets_prepare(db_path, "Immune system")
  })
  
  message("[scType Step 3/5] Performing scType scoring...")
  es.max <- sctype_score(
    scRNAseqData = GetAssayData(seurat_obj, assay = "RNA", layer = "data"),
    scaled = FALSE,
    gs = gs_list$gs_positive,
    gs2 = gs_list$gs_negative
  )
  message("Scoring completed. Dimension of score matrix: ", paste(dim(es.max), collapse = " x "))
  
  message("[scType Step 4/5] Identifying top cell types...")
  n_gs <- names(gs_list$gs_positive)
  es.max.cl <- apply(es.max, 2, function(x) {
    if (max(x) > 0) {
      n_gs[which.max(x)]
    } else {
      "Unknown"
    }
  })
  message("Cell types identified. First 6 results: ", paste(head(es.max.cl), collapse = ", "))
  
  message("[scType Step 5/5] Adding 'sctype_celltype' to metadata...")
  seurat_obj@meta.data$sctype_celltype <- es.max.cl
  
  # 最後の確認
  if("sctype_celltype" %in% colnames(seurat_obj@meta.data)){
      message("✅ Success! 'sctype_celltype' column was added to Seurat object metadata.")
  } else {
      message("❌ Failure! 'sctype_celltype' column was NOT added.")
  }
  
  return(seurat_obj)
}

run_seurat_object <- function(myReactives) {
  req(myReactives$seurat_object)
  seurat_object <- myReactives$seurat_object
  
  tryCatch({
    message("--- [Seurat Process] Starting basic Seurat processing ---")
    
    # --- メタデータとQC ---
    message("[Seurat Process Step 1/7] Adding metadata and calculating mitochondrial percentage...")
    if(is.null(rownames(seurat_object@meta.data))) rownames(seurat_object@meta.data) <- colnames(seurat_object)
    seurat_object@meta.data <- seurat_object@meta.data %>%
      tibble::rownames_to_column("barcode") %>%
      mutate(sample = tryCatch(str_remove(barcode, "^.+-" ), error = function(e) { 
        warning("Could not extract sample from barcode."); NA_character_ 
      })) %>%
      tibble::column_to_rownames("barcode")
    seurat_object[["percent.mt"]] <- Seurat::PercentageFeatureSet(seurat_object, pattern = "^MT-")
    message("Completed metadata and QC.")

    # --- 正規化 ---
    message("[Seurat Process Step 2/7] Normalizing data...")
    seurat_object <- Seurat::NormalizeData(seurat_object)
    message("Completed NormalizeData.")

    # --- 変動遺伝子の検出 ---
    message("[Seurat Process Step 3/7] Finding variable features...")
    seurat_object <- Seurat::FindVariableFeatures(seurat_object, selection.method = "vst", nfeatures = 2000)
    message("Completed FindVariableFeatures.")

    # --- スケーリング ---
    message("[Seurat Process Step 4/7] Scaling data...")
    all.genes <- rownames(seurat_object)
    seurat_object <- Seurat::ScaleData(seurat_object, features = all.genes)
    message("Completed ScaleData.")

    # --- PCA ---
    message("[Seurat Process Step 5/7] Running PCA...")
    seurat_object <- Seurat::RunPCA(seurat_object, features = Seurat::VariableFeatures(object = seurat_object), npcs = 50)
    # PCAの結果が存在するか確認
    if ("pca" %in% names(seurat_object@reductions)) {
      message("✅ RunPCA successful. PCA dimensions: ", paste(dim(seurat_object[['pca']]), collapse = " x "))
    } else {
      stop("❌ RunPCA failed. No 'pca' reduction found in the object.")
    }

    # --- UMAP & t-SNE ---
    dims_to_use <- 1:min(30, ncol(seurat_object[['pca']]))
    message("Using dimensions 1:", max(dims_to_use), " for UMAP and t-SNE.")
    
    message("[Seurat Process Step 6/7] Running UMAP...")
    seurat_object <- Seurat::RunUMAP(seurat_object, dims = dims_to_use)
    # UMAPの結果が存在するか確認
    if ("umap" %in% names(seurat_object@reductions)) {
      message("✅ RunUMAP successful.")
    } else {
      warning("❌ RunUMAP failed or did not complete. No 'umap' reduction found.")
    }

    message("[Seurat Process Step 7/7] Running t-SNE...")
    seurat_object <- Seurat::RunTSNE(seurat_object, dims = dims_to_use)
    # t-SNEの結果が存在するか確認
    if ("tsne" %in% names(seurat_object@reductions)) {
      message("✅ RunTSNE successful.")
    } else {
      warning("❌ RunTSNE failed or did not complete. No 'tsne' reduction found.")
    }
    
    # --- クラスタリング ---
    # UMAP/t-SNEの後でクラスタリングを実行
    message("[Seurat Process] Finding neighbors and clusters...")
    seurat_object <- Seurat::FindNeighbors(seurat_object, dims = dims_to_use)
    seurat_object <- Seurat::FindClusters(seurat_object, resolution = 0.5)
    message("Clustering complete.")

    myReactives$seurat_object <- seurat_object
    myReactives$meta.data <- seurat_object@meta.data
    # saveRDS(myReactives$seurat_object, 'seurat_object.rds') # 個別の保存は不要に
    
    message("--- [Seurat Process] All steps finished successfully! ---")
    
  }, error = function(e) {
    # エラーが発生した場合、コンソールに詳細なメッセージを表示
    message("!!!!!!!!!! Error in run_seurat_object !!!!!!!!!!")
    message("Error message: ", e$message)
    shinyalert::shinyalert("Seurat Processing Error", e$message, type = "error")
  })
  
  return(myReactives)
}

# この関数は変更なしでOKです！
fileUpload <- function(input, myReactives) {
  myReactives$h5_path <- input$h5$datapath
  myReactives$tcr_path <- input$tcr$datapath
  myReactives$bcr_path <- input$bcr$datapath
  return(myReactives)
}


# (パッケージとしてビルドする場合の推奨記述)
#' @importFrom dplyr %>% mutate case_when relocate starts_with coalesce across ends_with na_if select all_of any_of filter distinct full_join rename_with rename everything
#' @importFrom stringr str_c str_replace_all
#' @importFrom tidyselect everything
#' @importFrom readr read_csv
#' @importFrom scRepertoire combineTCR
#' @importFrom stats setNames
#' @importFrom rlang sym .data

# --- 定数定義 ---
PREFIX_TCR_PAIR  <- "TCR_pair_"
PREFIX_TCR_ALPHA <- "TCR_TRA_" # Alpha鎖 (TRA)
PREFIX_TCR_BETA  <- "TCR_TRB_" # Beta鎖 (TRB)

PREFIX_BCR_PAIR  <- "BCR_pair_" # Assuming this constant is needed for BCR processing


# --- ヘルパー関数定義 ---
# (csv_to_tcr_pair_dataframe, csv_to_tcr_tra_dataframe, csv_to_tcr_trb_dataframe, merge_tcr, paste_existing_cols は変更なし)
# (省略のため、ここでは再掲しません)
# --- (省略されたヘルパー関数) ---
#' @title CSVからTCRペア鎖データを抽出・整形
#' @description 指定されたCSVファイルからscRepertoire::combineTCRを使用して
#'              ペア鎖データ (主にTRA/TRB) を抽出し、整形します。
#'              同一barcodeに複数α/β鎖がある場合はフィルタリングします (filterMulti=TRUE)。
#' @param csv_path `character(1)`. 入力CSVファイルのパス。
#' @param sample_name `character(1)`. combineTCRで使用する一時的なサンプル名。デフォルトは "temp_sample"。
#' @param id_name `character(1)`. combineTCRで使用する一時的なID名。デフォルトは "temp_id"。
#' @return `data.frame`. 整形されたTCRペア鎖情報。列名は `PREFIX_TCR_PAIR` 付与。
csv_to_tcr_pair_dataframe <- function(csv_path,
                                      sample_name = "temp_sample",
                                      id_name = "temp_id") {

  barcode_prefix <- paste0(sample_name, "_", id_name, "_")
  tcr_raw <- tryCatch({
    readr::read_csv(csv_path, show_col_types = FALSE)
  }, error = function(e) {
    stop("Error reading CSV file: ", csv_path, "\n", e$message)
    return(NULL)
  })
  if (is.null(tcr_raw)) return(NULL)

  pair_list <- tryCatch({
    scRepertoire::combineTCR(tcr_raw, samples = sample_name, ID = id_name, filterMulti = TRUE, removeNA = TRUE)
  }, error = function(e) {
    stop("Error in combineTCR: ", e$message)
    return(NULL)
  })

  if (is.null(pair_list) || length(pair_list) == 0 || is.null(pair_list[[1]])) {
    warning("combineTCR did not return valid pair data.")
    return(data.frame()) # 空のデータフレームを返す
  }
  pair <- pair_list[[1]]

  pair <- pair %>%
    dplyr::mutate(barcode = stringr::str_replace_all(barcode, pattern = barcode_prefix, replacement = "")) %>%
    dplyr::select(-dplyr::any_of(c("sample", "ID"))) %>%
    dplyr::rename_with(~ stringr::str_c(PREFIX_TCR_PAIR, .), dplyr::everything())

  return(pair)
}

# Assuming csv_to_bcr_pair_dataframe exists in this file,
# analogous to csv_to_tcr_pair_dataframe, and contains the problematic call.
# The following is a hypothetical reconstruction to show the fix.
#' @title CSVからBCRペア鎖データを抽出・整形
#' @description 指定されたCSVファイルからscRepertoire::combineBCRを使用して
#'              ペア鎖データ (主にIGH/IGL/IGK) を抽出し、整形します。
#' @param csv_path `character(1)`. 入力CSVファイルのパス。
#' @param sample_name `character(1)`. combineBCRで使用する一時的なサンプル名。デフォルトは "temp_sample"。
#' @param id_name `character(1)`. combineBCRで使用する一時的なID名。デフォルトは "temp_id"。
#' @return `data.frame`. 整形されたBCRペア鎖情報。列名は `PREFIX_BCR_PAIR` 付与。
csv_to_bcr_pair_dataframe <- function(csv_path,
                                      sample_name = "temp_sample",
                                      id_name = "temp_id") {

  barcode_prefix <- paste0(sample_name, "_", id_name, "_")
  bcr_raw <- tryCatch({
    readr::read_csv(csv_path, show_col_types = FALSE)
  }, error = function(e) {
    stop("Error reading CSV file: ", csv_path, "\n", e$message)
    return(NULL)
  })
  if (is.null(bcr_raw)) return(NULL)

  pair_list <- tryCatch({
    # FIX: combineBCR does NOT have filterMulti = TRUE. Removed it.
    scRepertoire::combineBCR(bcr_raw, samples = sample_name, ID = id_name, removeNA = TRUE)
  }, error = function(e) {
    stop("Error in combineBCR: ", e$message)
    return(NULL)
  })

  if (is.null(pair_list) || length(pair_list) == 0 || is.null(pair_list[[1]])) {
    warning("combineBCR did not return valid pair data.")
    return(data.frame()) # 空のデータフレームを返す
  }
  pair <- pair_list[[1]]

  pair <- pair %>%
    dplyr::mutate(barcode = stringr::str_replace_all(barcode, pattern = barcode_prefix, replacement = "")) %>%
    dplyr::select(-dplyr::any_of(c("sample", "ID"))) %>%
    dplyr::rename_with(~ stringr::str_c(PREFIX_BCR_PAIR, .), dplyr::everything())

  return(pair)
}

#' @title CSVからTCR Alpha鎖(TRA)データを抽出・整形
#' @description 指定されたCSVファイルからTRA鎖のデータを抽出し、
#'              barcodeごとにユニークにして整形します。
#' @param csv_path `character(1)`. 入力CSVファイルのパス。
#' @return `data.frame`. 整形されたTCR TRA情報。列名は `PREFIX_TCR_ALPHA` 付与。
csv_to_tcr_tra_dataframe <- function(csv_path){

  tcr_raw <- tryCatch({
    readr::read_csv(csv_path, show_col_types = FALSE)
  }, error = function(e) {
    stop("Error reading CSV file: ", csv_path, "\n", e$message)
    return(NULL)
  })
  if (is.null(tcr_raw) || !"chain" %in% names(tcr_raw) || !"barcode" %in% names(tcr_raw)) {
    warning("CSV file must contain 'chain' and 'barcode' columns.")
    return(data.frame()) # エラーではなく空を返す
  }

  TRA <- tcr_raw %>%
    dplyr::filter(chain == 'TRA') %>%
    dplyr::distinct(barcode, .keep_all = TRUE) %>%
    dplyr::rename_with(~ stringr::str_c(PREFIX_TCR_ALPHA, .), dplyr::everything())

  return(TRA)
}

#' @title CSVからTCR Beta鎖(TRB)データを抽出・整形
#' @description 指定されたCSVファイルからTRB鎖のデータを抽出し、
#'              barcodeごとにユニークにして整形します。
#' @param csv_path `character(1)`. 入力CSVファイルのパス。
#' @return `data.frame`. 整形されたTCR TRB情報。列名は `PREFIX_TCR_BETA` 付与。
csv_to_tcr_trb_dataframe <- function(csv_path){

  tcr_raw <- tryCatch({
    readr::read_csv(csv_path, show_col_types = FALSE)
  }, error = function(e) {
    stop("Error reading CSV file: ", csv_path, "\n", e$message)
    return(NULL)
  })
  if (is.null(tcr_raw) || !"chain" %in% names(tcr_raw) || !"barcode" %in% names(tcr_raw)) {
    warning("CSV file must contain 'chain' and 'barcode' columns.")
    return(data.frame()) # エラーではなく空を返す
  }

  TRB <- tcr_raw %>%
    dplyr::filter(chain == 'TRB') %>%
    dplyr::distinct(barcode, .keep_all = TRUE) %>%
    dplyr::rename_with(~ stringr::str_c(PREFIX_TCR_BETA, .), dplyr::everything())

  return(TRB)
}

#' @title TCR各鎖データを結合
#' @description ペア鎖、Alpha鎖(TRA)、Beta鎖(TRB)のデータフレームをbarcodeをキーにして結合します。
#' @param pair `data.frame`. `csv_to_tcr_pair_dataframe` の出力。
#' @param TRA `data.frame`. `csv_to_tcr_tra_dataframe` の出力。
#' @param TRB `data.frame`. `csv_to_tcr_trb_dataframe` の出力。
#' @return `data.frame`. 結合されたTCRデータフレーム。
merge_tcr <- function(pair, TRA, TRB){

  pair_barcode_col <- paste0(PREFIX_TCR_PAIR, "barcode")
  tra_barcode_col  <- paste0(PREFIX_TCR_ALPHA, "barcode")
  trb_barcode_col  <- paste0(PREFIX_TCR_BETA, "barcode")

  # pair が空なら空を返す
  if (nrow(pair) == 0) {
      warning("Input 'pair' data frame is empty in merge_tcr. Returning empty data frame.")
      return(data.frame())
  }
  # TRA または TRB が空の場合でも結合は可能 (full_joinのため)
  if (nrow(TRA) == 0) warning("Input 'TRA' data frame is empty in merge_tcr.")
  if (nrow(TRB) == 0) warning("Input 'TRB' data frame is empty in merge_tcr.")


  tcr_merged <- dplyr::full_join(pair, TRA, by = stats::setNames(tra_barcode_col, pair_barcode_col))
  tcr_merged <- dplyr::full_join(tcr_merged, TRB, by = stats::setNames(trb_barcode_col, pair_barcode_col))

  return(tcr_merged)
}

#' @title 存在する列の値を連結する内部ヘルパー関数
#' @description データフレームと列名のベクトルを受け取り、存在する列の値を行ごとに連結。
#' @param df `data.frame`. 対象のデータフレーム。
#' @param cols `character`. 連結したい列名のベクトル。
#' @return `character`. 各行について連結された文字列ベクトル。
paste_existing_cols <- function(df, cols) {
  existing_cols <- intersect(cols, names(df))
  if (length(existing_cols) == 0) {
    return(rep(NA_character_, nrow(df)))
  }
  # apply を使うより rowwise + paste0/unite の方が dplyr 的かもしれないが、
  # NA処理を含めると apply の方が簡潔な場合もある
  apply(df[, existing_cols, drop = FALSE], 1, function(row_values) {
      # NA を空文字に変換してから結合
      row_values_no_na <- ifelse(is.na(row_values), "", row_values)
      paste0(row_values_no_na, collapse = "")
  })
}
# --- メイン関数定義 (修正版) ---

#' @title CSVからTCRデータを処理するメイン関数 (代表ID修正・ペア必須版)
#' @description 指定されたCSVファイルからTCRデータ (主にTRA/TRB) を読み込み、
#'              ペア鎖、Alpha鎖、Beta鎖に分割・整形した後、結合し、TRB鎖のIDを
#'              元に代表ID (`raw_clonotype_id` と `exact_subclonotype_id`) を格納し、
#'              全長配列を生成し、列順序を整え、barcode列名を変更します。
#'              `raw_consensus_id` は削除されます。
#'              `exact_subclonotype_id` は TRB の `raw_clonotype_id` と
#'              `exact_subclonotype_id` を `_` で連結した値になります。
#'              **最終的にTRA鎖とTRB鎖の両方が存在する行のみを保持します。**
#' @param csv_path `character(1)`. 入力CSVファイルのパス。
#' @return `data.frame`. 全ての処理が完了し、TRA/TRBペアが存在する行のみを含むTCRデータフレーム。
#'         処理中にエラーが発生した場合や、有効なペアデータが見つからない場合は、
#'         空のデータフレームまたは警告付きの部分的な結果を返すことがあります。
tcr_csv_to_dataframe <- function(csv_path){

  # --- 1. 入力チェック ---
  if (!file.exists(csv_path)) {
    stop("Input CSV file not found: ", csv_path)
    return(NULL)
  }

  # --- 2. データ抽出・整形 ---
  pair_data <- csv_to_tcr_pair_dataframe(csv_path)
  tra_data  <- csv_to_tcr_tra_dataframe(csv_path)
  trb_data  <- csv_to_tcr_trb_dataframe(csv_path)

  if (is.null(pair_data) || nrow(pair_data) == 0 || !paste0(PREFIX_TCR_PAIR, "barcode") %in% names(pair_data)) {
      warning("No valid paired TCR data found or extracted. Returning an empty data frame.")
      return(data.frame())
  }
  if (is.null(tra_data) || nrow(tra_data) == 0) {
      warning("No TRA data extracted. Final result might be empty after filtering.")
  }
  if (is.null(trb_data) || nrow(trb_data) == 0) {
      warning("No TRB data extracted. Final result might be empty after filtering.")
  }

  # --- 3. データ結合 ---
  merged_df <- merge_tcr(pair_data, tra_data, trb_data)

  pair_barcode_col_check <- paste0(PREFIX_TCR_PAIR, "barcode")
  if (nrow(merged_df) == 0 || !pair_barcode_col_check %in% names(merged_df)) {
    warning("Merging TCR data resulted in an empty data frame or missing key barcode column. Returning the empty frame.")
    return(merged_df)
  }

  # --- 4. 代表ID生成と不要列削除 (★修正箇所★) ---
  # TRB鎖のIDを元に代表IDを生成
  trb_clonotype_col <- paste0(PREFIX_TCR_BETA, "raw_clonotype_id")
  trb_subclonotype_col <- paste0(PREFIX_TCR_BETA, "exact_subclonotype_id")
  # raw_consensus_id はここで生成しない

  # 削除対象の元のID列名 (TRA, TRB, Pair) - consensusも含む
  cols_to_remove <- c(
    paste0(PREFIX_TCR_ALPHA, c("raw_clonotype_id", "raw_consensus_id", "exact_subclonotype_id")),
    paste0(PREFIX_TCR_BETA, c("raw_clonotype_id", "raw_consensus_id", "exact_subclonotype_id")),
    paste0(PREFIX_TCR_PAIR, c("raw_clonotype_id", "raw_consensus_id", "exact_subclonotype_id"))
  )
  # データフレームに実際に存在する列のみを削除対象とする
  cols_to_remove_existing <- intersect(cols_to_remove, names(merged_df))

  processed_df <- merged_df %>%
    dplyr::mutate(
      # raw_clonotype_id は TRB由来のものをそのまま使用
      raw_clonotype_id = if (trb_clonotype_col %in% names(.)) .data[[trb_clonotype_col]] else NA_character_,
      # exact_subclonotype_id は TRB由来の raw_clonotype_id と exact_subclonotype_id を連結
      exact_subclonotype_id = dplyr::case_when(
        # 両方の列が存在し、かつ両方の値が NA でない場合のみ連結
        trb_clonotype_col %in% names(.) & trb_subclonotype_col %in% names(.) &
          !is.na(.data[[trb_clonotype_col]]) & !is.na(.data[[trb_subclonotype_col]])
          ~ stringr::str_c(.data[[trb_clonotype_col]], .data[[trb_subclonotype_col]], sep = "_"),
        # それ以外の場合は NA
        TRUE ~ NA_character_
      )
      # raw_consensus_id はここで生成しない
    ) %>%
    # 不要になった元のTRA/TRB/PairのID列(+ consensus 列)を削除
    dplyr::select(-dplyr::any_of(cols_to_remove_existing)) %>%
    # もしマージや他の処理で raw_consensus_id 列が残ってしまった場合に備えて明示的に削除
    dplyr::select(-dplyr::any_of("raw_consensus_id"))


  # --- 5. 列順序の整理 (★修正箇所★) ---
  # 代表ID列、ペア列、Alpha列、Beta列の順に並べ替え (consensus を除外)
  processed_df <- processed_df %>%
    dplyr::relocate(
      # 代表ID列を先頭に (raw_consensus_id を除外)
      dplyr::any_of(c("raw_clonotype_id", "exact_subclonotype_id")),
      # 次に各プレフィックスを持つ列
      dplyr::starts_with(PREFIX_TCR_PAIR),
      dplyr::starts_with(PREFIX_TCR_ALPHA),
      dplyr::starts_with(PREFIX_TCR_BETA),
      .before = tidyselect::everything() # その他の列の前に配置
    )

  # --- 6. 全長配列の生成 ---
  regions_nt <- c("fwr1_nt", "cdr1_nt", "fwr2_nt", "cdr2_nt", "fwr3_nt", "cdr3_nt", "fwr4_nt")
  regions_aa <- c("fwr1", "cdr1", "fwr2", "cdr2", "fwr3", "cdr3", "fwr4")

  tra_nt_cols <- paste0(PREFIX_TCR_ALPHA, regions_nt)
  trb_nt_cols <- paste0(PREFIX_TCR_BETA, regions_nt)
  tra_aa_cols <- paste0(PREFIX_TCR_ALPHA, regions_aa)
  trb_aa_cols <- paste0(PREFIX_TCR_BETA, regions_aa)

  processed_df <- processed_df %>%
    dplyr::mutate(
      !!paste0(PREFIX_TCR_ALPHA, "full_length_nt") := paste_existing_cols(., tra_nt_cols),
      !!paste0(PREFIX_TCR_BETA, "full_length_nt") := paste_existing_cols(., trb_nt_cols),
      !!paste0(PREFIX_TCR_ALPHA, "full_length_aa") := paste_existing_cols(., tra_aa_cols),
      !!paste0(PREFIX_TCR_BETA, "full_length_aa") := paste_existing_cols(., trb_aa_cols)
    ) %>%
    dplyr::mutate(
      dplyr::across(
        dplyr::ends_with("full_length_nt") | dplyr::ends_with("full_length_aa"),
        ~ dplyr::na_if(., "")
      )
    )

  # --- 7. 最終的な列整理 (barcode) ---
  pair_barcode_col_rename <- paste0(PREFIX_TCR_PAIR, "barcode")
  if (!"barcode" %in% names(processed_df) && pair_barcode_col_rename %in% names(processed_df)) {
    processed_df <- processed_df %>%
      dplyr::rename(barcode = !!rlang::sym(pair_barcode_col_rename))
  } else if (!"barcode" %in% names(processed_df)) {
      warning(paste("Column", pair_barcode_col_rename, "not found for renaming and 'barcode' column also does not exist."))
  }

  if ("barcode" %in% names(processed_df)) {
    processed_df <- processed_df %>% dplyr::relocate(barcode)
  }

  # --- 8. TRA/TRBペアが存在する行のみフィルタリング ---
  tra_key_col <- paste0(PREFIX_TCR_ALPHA, "chain")
  trb_key_col <- paste0(PREFIX_TCR_BETA, "chain")

  if (tra_key_col %in% names(processed_df) && trb_key_col %in% names(processed_df)) {
      final_df <- processed_df %>%
          dplyr::filter(!is.na(.data[[tra_key_col]]) & !is.na(.data[[trb_key_col]]))

      if(nrow(final_df) == 0 && nrow(processed_df) > 0) {
          warning("Filtering removed all rows. No barcodes with both TRA and TRB chains found after merging.")
      }

  } else {
      missing_cols <- c()
      if (!tra_key_col %in% names(processed_df)) missing_cols <- c(missing_cols, tra_key_col)
      if (!trb_key_col %in% names(processed_df)) missing_cols <- c(missing_cols, trb_key_col)
      warning(paste("Key columns for filtering (", paste(missing_cols, collapse=", "), ") not found in the merged data frame. Skipping the final filtering step."))
      final_df <- processed_df
  }

  # --- 9. 結果を返す ---
  return(final_df)
}


# ★ addCelltype は外部スクリプトに依存するため注意が必要 ★
addCelltype <- function(myReactives) {
  req(myReactives$seurat_object)

  # --- 1. 実行前のメタデータ列名を取得 ---
  original_cols <- colnames(myReactives$seurat_object@meta.data)

  # --- 2. sctypeの実行 ---
  # 外部スクリプトの読み込みと実行
  tryCatch({
    # local=TRUE で現在の環境に関数を読み込む
    source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/sctype_wrapper.R", local = TRUE)

    if (exists("run_sctype", mode = "function")) {
      # sctypeのパラメータを定義
      sctype_name_param <- "sctype_classification"
      sctype_tissue_param <- "Immune system"

      # sctypeを実行
      myReactives$seurat_object <- run_sctype(
        myReactives$seurat_object,
        assay = "RNA",
        scaled = TRUE,
        known_tissue_type = sctype_tissue_param,
        custom_marker_file = "https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/ScTypeDB_short.xlsx",
        name = sctype_name_param
      )

      # --- 3. 追加された列を特定し、リネーム ---
      new_cols <- colnames(myReactives$seurat_object@meta.data)
      added_cols <- setdiff(new_cols, original_cols)

      # sctypeが一時的に追加する可能性のある 'cluster' 列を除外
      sctype_result_col <- setdiff(added_cols, "cluster")

      # 結果列が1つだけ追加されたことを確認
      if (length(sctype_result_col) == 1) {
        # 実際に追加された列を 'Celltype' にリネーム
        myReactives$seurat_object@meta.data <- myReactives$seurat_object@meta.data %>%
          dplyr::rename(Celltype = !!rlang::sym(sctype_result_col))
        message("Successfully renamed column '", sctype_result_col, "' to 'Celltype'.")
      } else if (length(sctype_result_col) > 1) {
        warning("sctype added multiple unexpected columns: ", paste(sctype_result_col, collapse = ", "), ". Could not reliably determine which to rename to 'Celltype'.")
      } else {
        # 予測していた列名も警告に含める
        expected_col_name_raw <- paste0(sctype_name_param, "_", sctype_tissue_param)
        expected_col_name_clean <- make.names(expected_col_name_raw)
        warning("Could not find the sctype result column. Expected something like '", expected_col_name_clean, "' but found these new columns: ", paste(added_cols, collapse = ", "))
      }

      # --- 4. 不要な一時列を削除 ---
      # sctype_wrapper.R は 'cluster' という列を追加することがあります。
      # 以前はこの関数内で削除していましたが、後続のUI更新処理が
      # この'cluster'列の存在を前提としてエラーになる可能性があるため、
      # ここでは削除しないように変更します。後続の処理で不要な列として扱われることを想定しています。
      # if ("cluster" %in% added_cols) {
      #   myReactives$seurat_object@meta.data$cluster <- NULL
      # }
    } else {
      warning("run_sctype function not found after sourcing script.")
    }
  }, error = function(e) {
    warning("Failed to source or run sctype: ", e$message)
  })
  return(myReactives)
}